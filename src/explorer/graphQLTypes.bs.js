/* eslint-disable */
// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var List = require('bs-platform/lib/js/list.js');
var $$Array = require('bs-platform/lib/js/array.js');
var Block = require('bs-platform/lib/js/block.js');
var Curry = require('bs-platform/lib/js/curry.js');
var $$String = require('bs-platform/lib/js/string.js');
var Graphql = require('graphql');
var Caml_obj = require('bs-platform/lib/js/caml_obj.js');
var Js_primitive = require('bs-platform/lib/js/js_primitive.js');
var Js_null_undefined = require('bs-platform/lib/js/js_null_undefined.js');
var Caml_builtin_exceptions = require('bs-platform/lib/js/caml_builtin_exceptions.js');
var Option$GraphiqlExplorer = require('../option.bs.js');
var ReGraphQL$GraphiqlExplorer = require('../graphql/ReGraphQL.bs.js');

var stringification = function(nullableValue) {
  if (
    typeof nullableValue === 'undefined' ||
    (nullableValue === null && typeof nullableValue === 'object')
  ) {
    return null;
  } else {
    return nullableValue.toString();
  }
};

function maybeFind(needle, haystack) {
  try {
    return /* Some */ Block.simpleVariant('Some', [
      List.assoc(needle, haystack),
    ]);
  } catch (exn) {
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */ 0;
    } else {
      throw exn;
    }
  }
}

function lowerCaseFirst(list) {
  if (list) {
    var rest = list[1];
    var head = list[0];
    if (rest) {
      return /* :: */ Block.simpleVariant('::', [head.toLowerCase(), rest]);
    } else {
      return /* :: */ Block.simpleVariant('::', [
        head.toLowerCase(),
        /* [] */ 0,
      ]);
    }
  } else {
    return /* [] */ 0;
  }
}

function updateFieldAt(schema, root, fieldPath, update) {
  var findAndUpdateEntry = function(
    depth,
    param,
    entryGQLType,
    traversedPieces,
    pieces,
  ) {
    var entry = param[1];
    if (pieces) {
      var nextStep = pieces[0];
      var path = List.concat(
        /* :: */ Block.simpleVariant('::', [
          traversedPieces,
          /* :: */ Block.simpleVariant('::', [
            /* :: */ Block.simpleVariant('::', [nextStep, /* [] */ 0]),
            /* [] */ 0,
          ]),
        ]),
      );
      var nextGQLTypeCont = /* None */ 0;
      var next;
      try {
        var match = List.assoc(nextStep, entry[/* children */ 5]);
        var entry$1 = match[1];
        var nextGQLType = Graphql.getNamedType(
          depth !== 0 ? entry$1[/* field */ 2]['type'] : entry$1[/* field */ 2],
        );
        nextGQLTypeCont = /* Some */ Block.simpleVariant('Some', [nextGQLType]);
        next = /* tuple */ [match[0], entry$1];
      } catch (exn) {
        if (exn === Caml_builtin_exceptions.not_found) {
          var field;
          if (depth !== 0) {
            var n = Curry._2(
              ReGraphQL$GraphiqlExplorer
                .Schema[/* Field */ 3][/* fieldForType */ 3],
              Graphql.getNamedType(entryGQLType),
              nextStep,
            );
            var n$prime = Option$GraphiqlExplorer.expect(
              'FieldForType-' + nextStep,
              n,
            );
            var subType = Graphql.getNamedType(n$prime['type']);
            nextGQLTypeCont = /* Some */ Block.simpleVariant('Some', [subType]);
            field = n$prime;
          } else {
            var r = Graphql.getNamedType(entryGQLType);
            nextGQLTypeCont = /* Some */ Block.simpleVariant('Some', [
              entryGQLType,
            ]);
            field = r;
          }
          var nextEntry_004 = /* path */ $$String.concat('.', path);
          var nextEntry = /* record */ Block.record(
            ['name', 'checked', 'field', 'args', 'path', 'children'],
            [nextStep, false, field, 0, nextEntry_004, 0],
          );
          next = /* tuple */ [0, nextEntry];
        } else {
          throw exn;
        }
      }
      var nextGQLType$1 = Option$GraphiqlExplorer.expect(
        'GQLType-' + nextStep,
        nextGQLTypeCont,
      );
      var next$prime_001 = findAndUpdateEntry(
        (depth + 1) | 0,
        next,
        nextGQLType$1,
        path,
        pieces[1],
      );
      var next$prime = /* tuple */ [0, next$prime_001];
      var otherChildren = List.filter(function(param) {
        return param[0] !== nextStep;
      })(entry[/* children */ 5]);
      return /* record */ Block.record(
        ['name', 'checked', 'field', 'args', 'path', 'children'],
        [
          entry[/* name */ 0],
          entry[/* checked */ 1],
          entry[/* field */ 2],
          entry[/* args */ 3],
          entry[/* path */ 4],
          Block.simpleVariant('::', [
            /* tuple */ [nextStep, next$prime],
            otherChildren,
          ]),
        ],
      );
    } else {
      return Curry._1(update, entry);
    }
  };
  var pieces$prime = $$Array.to_list(fieldPath.split('.'));
  var pieces;
  if (pieces$prime) {
    var rest = pieces$prime[1];
    var head = pieces$prime[0];
    pieces = rest
      ? /* :: */ Block.simpleVariant('::', [head.toLowerCase(), rest])
      : /* :: */ Block.simpleVariant('::', [head.toLowerCase(), /* [] */ 0]);
  } else {
    pieces = /* [] */ 0;
  }
  var other = List.hd(pieces).toLowerCase();
  var gqlType$prime;
  switch (other) {
    case 'mutation':
      gqlType$prime = Js_primitive.null_undefined_to_opt(
        schema.getMutationType(),
      );
      break;
    case 'query':
      gqlType$prime = Js_primitive.null_undefined_to_opt(schema.getQueryType());
      break;
    case 'subscription':
      gqlType$prime = Js_primitive.null_undefined_to_opt(
        schema.getSubscriptionType(),
      );
      break;
    default:
      throw [
        Caml_builtin_exceptions.failure,
        'Unrecognized root field: ' + other,
      ];
  }
  var gqlType = Option$GraphiqlExplorer.expect('Base GQL Type', gqlType$prime);
  return findAndUpdateEntry(
    0,
    /* tuple */ [0, root],
    gqlType,
    /* [] */ 0,
    pieces,
  );
}

function fieldByPath(root, fieldPath) {
  var findEntry = function(param, pieces) {
    var entry = param[1];
    if (pieces) {
      try {
        return findEntry(
          List.assoc(pieces[0], entry[/* children */ 5]),
          pieces[1],
        );
      } catch (exn) {
        if (exn === Caml_builtin_exceptions.not_found) {
          return /* None */ 0;
        } else {
          throw exn;
        }
      }
    } else {
      return /* Some */ Block.simpleVariant('Some', [entry]);
    }
  };
  var pathPieces = lowerCaseFirst($$Array.to_list(fieldPath.split('.')));
  return findEntry(/* tuple */ [0, root], pathPieces);
}

function isFieldCheckedByPath(root, fieldPath) {
  var match = fieldByPath(root, fieldPath);
  if (match) {
    return match[0][/* checked */ 1];
  } else {
    return false;
  }
}

function stripOrdering(items) {
  return List.map(function(param) {
    return /* tuple */ [param[0], param[1][1]];
  }, items);
}

function gqlArgOfField(field, argPath) {
  var _argPathPieces = $$Array.to_list(argPath.split('.'));
  Curry._2(
    ReGraphQL$GraphiqlExplorer.Schema[/* Field */ 3][/* argFieldByPath */ 4],
    field,
    _argPathPieces,
  );
  return /* None */ 0;
}

function toggleFieldByPath(schema, root, fieldPath) {
  return updateFieldAt(schema, root, fieldPath, function(entry) {
    return /* record */ Block.record(
      ['name', 'checked', 'field', 'args', 'path', 'children'],
      [
        entry[/* name */ 0],
        !entry[/* checked */ 1],
        entry[/* field */ 2],
        entry[/* args */ 3],
        entry[/* path */ 4],
        entry[/* children */ 5],
      ],
    );
  });
}

function entryArgByName(entry, name) {
  return maybeFind(name, entry[/* args */ 3]);
}

function argByPath(root, fieldPath, argPath) {
  return Option$GraphiqlExplorer.fmap(fieldByPath(root, fieldPath), function(
    entry,
  ) {
    var findArg = function(argFieldT, pieces) {
      return Option$GraphiqlExplorer.fmap(argFieldT, function(argField) {
        if (pieces) {
          return findArg(
            maybeFind(pieces[0], argField[/* children */ 5]),
            pieces[1],
          );
        } else {
          return /* Some */ Block.simpleVariant('Some', [
            /* ArgField */ Block.variant('ArgField', 1, [argField]),
          ]);
        }
      });
    };
    var argPathPieces = $$Array.to_list(argPath.split('.'));
    if (argPathPieces) {
      var rest = argPathPieces[1];
      var head = argPathPieces[0];
      if (rest) {
        return Option$GraphiqlExplorer.fmap(
          maybeFind(head, entry[/* args */ 3]),
          function(arg) {
            return findArg(arg[/* subField */ 4], rest);
          },
        );
      } else {
        return Option$GraphiqlExplorer.map(
          maybeFind(head, entry[/* args */ 3]),
          function(arg) {
            return /* Arg */ Block.variant('Arg', 0, [arg]);
          },
        );
      }
    } else {
      throw [Caml_builtin_exceptions.failure, 'bad arg path (empty)'];
    }
  });
}

function isArgCheckedByPath(root, fieldPath, argPath) {
  return Option$GraphiqlExplorer.$$default(
    false,
    Option$GraphiqlExplorer.map(argByPath(root, fieldPath, argPath), function(
      arg,
    ) {
      if (arg.tag) {
        return arg[0][/* checked */ 3];
      } else {
        return arg[0][/* checked */ 1];
      }
    }),
  );
}

function argValueByPath(root, fieldPath, argPath) {
  return Option$GraphiqlExplorer.fmap(
    argByPath(root, fieldPath, argPath),
    function(arg) {
      if (arg.tag) {
        return arg[0][/* value */ 4];
      } else {
        return Option$GraphiqlExplorer.fmap(arg[0][/* subField */ 4], function(
          field,
        ) {
          return field[/* value */ 4];
        });
      }
    },
  );
}

function isFieldGQLObjectOrInputObject(field) {
  var currentFieldBaseType = Graphql.getNamedType(field['type']);
  var match =
    Graphql.isInputObjectType(currentFieldBaseType) ||
    Graphql.isInputObjectType(currentFieldBaseType);
  if (match) {
    return /* Some */ Block.simpleVariant('Some', [currentFieldBaseType]);
  } else {
    return /* None */ 0;
  }
}

function appendChildUniq(list, childName, child) {
  var otherChildren = List.filter(function(param) {
    return Caml_obj.caml_notequal(param[0], childName);
  })(list);
  return List.append(
    otherChildren,
    /* :: */ Block.simpleVariant('::', [
      /* tuple */ [childName, child],
      /* [] */ 0,
    ]),
  );
}

function makeDefaultArgField(name, field, path) {
  return /* record */ Block.record(
    ['name', 'field', 'path', 'checked', 'value', 'children'],
    [name, field, path, false, 0, 0],
  );
}

function findAndUpdateArgField(argField, argPath, update) {
  if (argPath) {
    var rest = argPath[1];
    var head = argPath[0];
    var finder = function(param) {
      return param[0] === head;
    };
    var match = List.exists(finder, argField[/* children */ 5]);
    if (match) {
      var match$1 = List.find(finder, argField[/* children */ 5]);
      var nextArgField = match$1[1];
      var nextChild = findAndUpdateArgField(nextArgField, rest, update);
      if (nextChild) {
        var child = nextChild[0];
        return /* Some */ Block.simpleVariant('Some', [
          /* record */ Block.record(
            ['name', 'field', 'path', 'checked', 'value', 'children'],
            [
              argField[/* name */ 0],
              argField[/* field */ 1],
              argField[/* path */ 2],
              argField[/* checked */ 3],
              argField[/* value */ 4],
              appendChildUniq(
                argField[/* children */ 5],
                child[/* name */ 0],
                child,
              ),
            ],
          ),
        ]);
      } else {
        return /* Some */ Block.simpleVariant('Some', [nextArgField]);
      }
    } else {
      return Option$GraphiqlExplorer.fmap(
        isFieldGQLObjectOrInputObject(argField[/* field */ 1]),
        function(currentFieldBaseType) {
          return Option$GraphiqlExplorer.fmap(
            Option$GraphiqlExplorer.map(
              Curry._2(
                ReGraphQL$GraphiqlExplorer
                  .Schema[/* ObjectType */ 4][/* getField */ 1],
                currentFieldBaseType,
                head,
              ),
              function(gqlField) {
                return makeDefaultArgField(
                  head,
                  gqlField,
                  argField[/* path */ 2] + ('.' + head),
                );
              },
            ),
            function(nextArgField) {
              var nextChild = findAndUpdateArgField(nextArgField, rest, update);
              if (nextChild) {
                var child = nextChild[0];
                return /* Some */ Block.simpleVariant('Some', [
                  /* record */ Block.record(
                    ['name', 'field', 'path', 'checked', 'value', 'children'],
                    [
                      argField[/* name */ 0],
                      argField[/* field */ 1],
                      argField[/* path */ 2],
                      argField[/* checked */ 3],
                      argField[/* value */ 4],
                      appendChildUniq(
                        argField[/* children */ 5],
                        child[/* name */ 0],
                        child,
                      ),
                    ],
                  ),
                ]);
              } else {
                return /* Some */ Block.simpleVariant('Some', [nextArgField]);
              }
            },
          );
        },
      );
    }
  } else {
    var match$2 = Curry._1(
      update,
      /* ArgField */ Block.variant('ArgField', 1, [argField]),
    );
    if (match$2.tag) {
      return /* Some */ Block.simpleVariant('Some', [match$2[0]]);
    } else {
      throw [
        Caml_builtin_exceptions.failure,
        'Got arg back when expected argSubField',
      ];
    }
  }
}

function makeDefaultArgEntry(name, argType) {
  var gqlField = {
    args: /* array */ [],
    deprecationReason: Js_null_undefined.fromOption(/* None */ 0),
    description: Js_null_undefined.fromOption(/* None */ 0),
    isDeprecated: false,
    name: name,
  };
  gqlField['type'] = argType;
  var subField = /* record */ Block.record(
    ['name', 'field', 'path', 'checked', 'value', 'children'],
    [name, gqlField, name, false, 0, 0],
  );
  return /* record */ Block.record(
    ['name', 'checked', 'typ', 'path', 'subField'],
    [name, false, argType, name, Block.simpleVariant('Some', [subField])],
  );
}

function findAndUpdateArgEntry(fieldEntry, argPath, update) {
  if (argPath) {
    var rest = argPath[1];
    var head = argPath[0];
    if (rest) {
      var match = maybeFind(head, fieldEntry[/* args */ 3]);
      if (match) {
        var argEntry = match[0];
        var match$1 = argEntry[/* subField */ 4];
        if (match$1) {
          var newField = findAndUpdateArgField(match$1[0], rest, update);
          return /* Some */ Block.simpleVariant('Some', [
            /* record */ Block.record(
              ['name', 'checked', 'typ', 'path', 'subField'],
              [
                argEntry[/* name */ 0],
                argEntry[/* checked */ 1],
                argEntry[/* typ */ 2],
                argEntry[/* path */ 3],
                newField,
              ],
            ),
          ]);
        } else {
          return /* None */ 0;
        }
      } else {
        throw [
          Caml_builtin_exceptions.failure,
          "findAndUpdateArgEntry.1.1: Couldn't maybeFind arg",
        ];
      }
    } else {
      var maybeEntry = maybeFind(head, fieldEntry[/* args */ 3]);
      var tmp;
      if (maybeEntry) {
        tmp = /* Some */ Block.simpleVariant('Some', [maybeEntry[0]]);
      } else {
        var arg = Curry._2(
          ReGraphQL$GraphiqlExplorer.Schema[/* Field */ 3][/* argByName */ 1],
          fieldEntry[/* field */ 2],
          head,
        );
        if (arg) {
          var argType = Graphql.getNamedType(arg[0]['type']);
          var argEntry$1 = makeDefaultArgEntry(head, argType);
          tmp = /* Some */ Block.simpleVariant('Some', [argEntry$1]);
        } else {
          tmp = /* None */ 0;
        }
      }
      return Option$GraphiqlExplorer.map(
        Option$GraphiqlExplorer.map(tmp, function(arg) {
          return Curry._1(update, /* Arg */ Block.variant('Arg', 0, [arg]));
        }),
        function(argish) {
          if (argish.tag) {
            throw [
              Caml_builtin_exceptions.failure,
              'Got field back when expected argEntry',
            ];
          } else {
            return argish[0];
          }
        },
      );
    }
  } else {
    throw [
      Caml_builtin_exceptions.failure,
      'Bad (empty) argPath in findAndUpdateArgEntry',
    ];
  }
}

function updateArgAt(schema, root, fieldPath, argPath, update) {
  var argPathPieces = $$Array.to_list(argPath.split('.'));
  var updater = function(entry) {
    argValueByPath(root, fieldPath, argPath);
    var newArgEntryT = findAndUpdateArgEntry(entry, argPathPieces, update);
    if (newArgEntryT) {
      var newArgEntry = newArgEntryT[0];
      isArgCheckedByPath(root, fieldPath, argPath);
      var newArgs = List.append(
        /* :: */ Block.simpleVariant('::', [
          /* tuple */ [newArgEntry[/* name */ 0], newArgEntry],
          /* [] */ 0,
        ]),
        List.filter(function(param) {
          return param[0] !== newArgEntry[/* name */ 0];
        })(entry[/* args */ 3]),
      );
      return /* record */ Block.record(
        ['name', 'checked', 'field', 'args', 'path', 'children'],
        [
          entry[/* name */ 0],
          entry[/* checked */ 1],
          entry[/* field */ 2],
          newArgs,
          entry[/* path */ 4],
          entry[/* children */ 5],
        ],
      );
    } else {
      return entry;
    }
  };
  return updateFieldAt(schema, root, fieldPath, updater);
}

function toggleArgByPath(schema, root, fieldPath, argPath) {
  return updateArgAt(schema, root, fieldPath, argPath, function(argish) {
    if (argish.tag) {
      var field = argish[0];
      var newField_000 = /* name */ field[/* name */ 0];
      var newField_001 = /* field */ field[/* field */ 1];
      var newField_002 = /* path */ field[/* path */ 2];
      var newField_003 = /* checked */ !field[/* checked */ 3];
      var newField_004 = /* value */ field[/* value */ 4];
      var newField_005 = /* children */ field[/* children */ 5];
      var newField = /* record */ Block.record(
        ['name', 'field', 'path', 'checked', 'value', 'children'],
        [
          newField_000,
          newField_001,
          newField_002,
          newField_003,
          newField_004,
          newField_005,
        ],
      );
      return /* ArgField */ Block.variant('ArgField', 1, [newField]);
    } else {
      var arg = argish[0];
      var isChecked = !arg[/* checked */ 1];
      var match = arg[/* subField */ 4];
      var subField;
      if (match) {
        var subField$1 = match[0];
        subField = /* Some */ Block.simpleVariant('Some', [
          /* record */ Block.record(
            ['name', 'field', 'path', 'checked', 'value', 'children'],
            [
              subField$1[/* name */ 0],
              subField$1[/* field */ 1],
              subField$1[/* path */ 2],
              isChecked,
              subField$1[/* value */ 4],
              subField$1[/* children */ 5],
            ],
          ),
        ]);
      } else {
        subField = /* None */ 0;
      }
      var newArg_000 = /* name */ arg[/* name */ 0];
      var newArg_002 = /* typ */ arg[/* typ */ 2];
      var newArg_003 = /* path */ arg[/* path */ 3];
      var newArg = /* record */ Block.record(
        ['name', 'checked', 'typ', 'path', 'subField'],
        [newArg_000, isChecked, newArg_002, newArg_003, subField],
      );
      return /* Arg */ Block.variant('Arg', 0, [newArg]);
    }
  });
}

function argishValue(argish) {
  if (argish.tag) {
    return argish[0][/* value */ 4];
  } else {
    return Option$GraphiqlExplorer.fmap(argish[0][/* subField */ 4], function(
      field,
    ) {
      return field[/* value */ 4];
    });
  }
}

function setArgValueByPath(schema, root, fieldPath, argPath, value) {
  return updateArgAt(schema, root, fieldPath, argPath, function(argish) {
    if (argish.tag) {
      var field = argish[0];
      var argField_000 = /* name */ field[/* name */ 0];
      var argField_001 = /* field */ field[/* field */ 1];
      var argField_002 = /* path */ field[/* path */ 2];
      var argField_003 = /* checked */ field[/* checked */ 3];
      var argField_005 = /* children */ field[/* children */ 5];
      var argField = /* record */ Block.record(
        ['name', 'field', 'path', 'checked', 'value', 'children'],
        [
          argField_000,
          argField_001,
          argField_002,
          argField_003,
          value,
          argField_005,
        ],
      );
      return /* ArgField */ Block.variant('ArgField', 1, [argField]);
    } else {
      var arg = argish[0];
      var field$1 = Option$GraphiqlExplorer.expect(
        'setArgValueByPath for Arg(arg)',
        arg[/* subField */ 4],
      );
      var field_000 = /* name */ field$1[/* name */ 0];
      var field_001 = /* field */ field$1[/* field */ 1];
      var field_002 = /* path */ field$1[/* path */ 2];
      var field_003 = /* checked */ field$1[/* checked */ 3];
      var field_005 = /* children */ field$1[/* children */ 5];
      var field$2 = /* record */ Block.record(
        ['name', 'field', 'path', 'checked', 'value', 'children'],
        [field_000, field_001, field_002, field_003, value, field_005],
      );
      var entry_000 = /* name */ arg[/* name */ 0];
      var entry_001 = /* checked */ arg[/* checked */ 1];
      var entry_002 = /* typ */ arg[/* typ */ 2];
      var entry_003 = /* path */ arg[/* path */ 3];
      var entry_004 = /* subField : Some */ Block.simpleVariant('Some', [
        field$2,
      ]);
      var entry = /* record */ Block.record(
        ['name', 'checked', 'typ', 'path', 'subField'],
        [entry_000, entry_001, entry_002, entry_003, entry_004],
      );
      return /* Arg */ Block.variant('Arg', 0, [entry]);
    }
  });
}

var rootField = {
  args: /* array */ [],
  deprecationReason: Js_null_undefined.fromOption(/* None */ 0),
  description: Js_null_undefined.fromOption(/* None */ 0),
  isDeprecated: false,
  name: 'Root',
};

function documentToTree(schema, text) {
  var addNestedArguments = function(depth, fieldPath, baseArgPath, dangerArg) {
    var match = dangerArg.value.kind;
    switch (match) {
      case 'ListValue':
      case 'ObjectValue':
        break;
      default:
    }
    var _other = dangerArg.value.kind;
    if (_other === 'ObjectValue') {
      var subfields = $$Array.to_list(
        Option$GraphiqlExplorer.$$default(
          /* array */ [],
          Js_primitive.null_undefined_to_opt(dangerArg.value.fields),
        ),
      );
      var argPath = baseArgPath
        ? baseArgPath[0] + ('.' + dangerArg.name.value)
        : dangerArg.name.value;
      return List.append(
        /* :: */ Block.simpleVariant('::', [
          /* CheckArg */ Block.variant('CheckArg', 1, [fieldPath, argPath]),
          /* [] */ 0,
        ]),
        List.concat(
          List.map(function(field) {
            return addNestedArguments(
              (depth + 1) | 0,
              fieldPath,
              /* Some */ Block.simpleVariant('Some', [argPath]),
              field,
            );
          }, subfields),
        ),
      );
    } else {
      var argPath$1 = baseArgPath
        ? baseArgPath[0] + ('.' + dangerArg.name.value)
        : dangerArg.name.value;
      var argValue = Curry._1(stringification, dangerArg.value.value);
      return /* :: */ Block.simpleVariant('::', [
        /* CheckArg */ Block.variant('CheckArg', 1, [fieldPath, argPath$1]),
        /* :: */ Block.simpleVariant('::', [
          /* SetArgValue */ Block.variant('SetArgValue', 2, [
            fieldPath,
            argPath$1,
            argValue == null
              ? /* None */ 0
              : Block.simpleVariant('Some', [argValue]),
          ]),
          /* [] */ 0,
        ]),
      ]);
    }
  };
  var addArgumentsFromSelection = function(fieldPath, selection) {
    var args = $$Array.to_list(
      Option$GraphiqlExplorer.$$default(
        /* array */ [],
        Js_primitive.null_undefined_to_opt(selection.arguments),
      ),
    );
    return List.concat(
      List.map(function(arg) {
        var match = arg.value.kind;
        var isNested;
        switch (match) {
          case 'ListValue':
          case 'ObjectValue':
            isNested = true;
            break;
          default:
            isNested = false;
        }
        if (isNested) {
          return List.append(
            /* [] */ 0,
            addNestedArguments(0, fieldPath, /* None */ 0, arg),
          );
        } else {
          var argPath = arg.name.value;
          var argValue = Curry._1(stringification, arg.value.value);
          return /* :: */ Block.simpleVariant('::', [
            /* CheckArg */ Block.variant('CheckArg', 1, [fieldPath, argPath]),
            /* :: */ Block.simpleVariant('::', [
              /* SetArgValue */ Block.variant('SetArgValue', 2, [
                fieldPath,
                argPath,
                argValue == null
                  ? /* None */ 0
                  : Block.simpleVariant('Some', [argValue]),
              ]),
              /* [] */ 0,
            ]),
          ]);
        }
      }, args),
    );
  };
  var addChildrenFromSelectionSet = function(rootPath, selectionSet) {
    var selections = $$Array.to_list(selectionSet.selections);
    var actions = List.concat(
      List.map(function(selection) {
        var name = selection.name.value;
        var path = rootPath + ('.' + name);
        var match = selection.selectionSet;
        return List.concat(
          /* :: */ Block.simpleVariant('::', [
            /* :: */ Block.simpleVariant('::', [
              /* CheckField */ Block.variant('CheckField', 0, [path]),
              /* [] */ 0,
            ]),
            /* :: */ Block.simpleVariant('::', [
              addArgumentsFromSelection(path, selection),
              /* :: */ Block.simpleVariant('::', [
                match == null
                  ? /* [] */ 0
                  : addChildrenFromSelectionSet(path, match),
                /* [] */ 0,
              ]),
            ]),
          ]),
        );
      }, selections),
    );
    return List.append(actions, /* [] */ 0);
  };
  var addDefinition = function(operation) {
    var name = operation.operation;
    var other = name.toLowerCase();
    var tmp;
    switch (other) {
      case 'mutation':
        tmp = Js_primitive.null_undefined_to_opt(schema.getMutationType());
        break;
      case 'query':
        tmp = Js_primitive.null_undefined_to_opt(schema.getQueryType());
        break;
      case 'subscription':
        tmp = Js_primitive.null_undefined_to_opt(schema.getSubscriptionType());
        break;
      default:
        throw [
          Caml_builtin_exceptions.failure,
          'Unrecognized operation kind: ' + other,
        ];
    }
    Option$GraphiqlExplorer.expect('addOperation findOperation', tmp);
    var action = /* CheckField */ Block.variant('CheckField', 0, [name]);
    var childrenActions = addChildrenFromSelectionSet(
      name,
      operation.selectionSet,
    );
    return /* :: */ Block.simpleVariant('::', [action, childrenActions]);
  };
  var parsed = Graphql.parse(text);
  var root = /* record */ Block.record(
    ['name', 'checked', 'field', 'args', 'path', 'children'],
    ['Root', true, rootField, 0, '', 0],
  );
  var actions = List.concat(
    List.map(addDefinition, $$Array.to_list(parsed.definitions)),
  );
  return List.fold_left(
    function(root, action) {
      switch (action.tag | 0) {
        case 0:
          return toggleFieldByPath(schema, root, action[0]);
        case 1:
          return toggleArgByPath(schema, root, action[0], action[1]);
        case 2:
          var argValue = action[2];
          var argPath = action[1];
          var fieldPath = action[0];
          console.log('SetArgValue: ', fieldPath, argPath, argValue);
          return setArgValueByPath(schema, root, fieldPath, argPath, argValue);
      }
    },
    root,
    actions,
  );
}

exports.stringification = stringification;
exports.maybeFind = maybeFind;
exports.lowerCaseFirst = lowerCaseFirst;
exports.updateFieldAt = updateFieldAt;
exports.fieldByPath = fieldByPath;
exports.isFieldCheckedByPath = isFieldCheckedByPath;
exports.stripOrdering = stripOrdering;
exports.gqlArgOfField = gqlArgOfField;
exports.toggleFieldByPath = toggleFieldByPath;
exports.entryArgByName = entryArgByName;
exports.argByPath = argByPath;
exports.isArgCheckedByPath = isArgCheckedByPath;
exports.argValueByPath = argValueByPath;
exports.isFieldGQLObjectOrInputObject = isFieldGQLObjectOrInputObject;
exports.appendChildUniq = appendChildUniq;
exports.makeDefaultArgField = makeDefaultArgField;
exports.findAndUpdateArgField = findAndUpdateArgField;
exports.makeDefaultArgEntry = makeDefaultArgEntry;
exports.findAndUpdateArgEntry = findAndUpdateArgEntry;
exports.updateArgAt = updateArgAt;
exports.toggleArgByPath = toggleArgByPath;
exports.argishValue = argishValue;
exports.setArgValueByPath = setArgValueByPath;
exports.rootField = rootField;
exports.documentToTree = documentToTree;
/* stringification Not a pure module */
